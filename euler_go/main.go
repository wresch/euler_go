package main


import (
	"fmt"
	"os"
	eu "github.org/wresch/euler_go"
)

var problems = map[string]func(){
	"1": problem1,
	"2": problem2,
	"3": problem3,
	"4": problem4,
	"5": problem5,
}

func main() {
	if len(os.Args) == 1 {
		fmt.Println("Usage: euler_go problem_nr")
		os.Exit(1)
	}
	if fun, ok := problems[os.Args[1]]; ok {
		fun()
	} else {
		fmt.Println("That problem was not solved yet; Solved problems:")
		for problem := range problems {
			fmt.Printf("%4s\n", problem)
		}
		os.Exit(1)
	}
}

func output(i int, desc string, solution interface{}) {
	fmt.Println("**********************************************************************")
	fmt.Printf("*                          Problem %4d                              *\n", i)
	fmt.Println("**********************************************************************")
	fmt.Printf("Description\n--------------------\n%s\n\n", desc)
	fmt.Printf("Solution\n--------------------\n%v\n", solution)
}


//////////////////// problem1 ////////////////////
func problem1() {
	desc := `
If we list all the natural numbers below 10 that are multiples
of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.

Find the sum of all the multiples of 3 or 5 below 1000.`
	var total int64 = 0
	for i := eu.NewLinearCounter(3, 3); i.Value < 1000; i.Next() {
		total += i.Value
	}
	for i := eu.NewLinearCounter(5, 5); i.Value < 1000; i.Next() {
		if i.Value % 3 == 0 {
			continue
		}
		total += i.Value
	}
	output(1, desc, total)
}

//////////////////// problem2 ////////////////////
func problem2() {
	desc := `
Each new term in the Fibonacci sequence is generated by adding the
previous two terms. By starting with 1 and 2, the first 10 terms will
be:

	1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

By considering the terms in the Fibonacci sequence whose values do not
exceed four million, find the sum of the even-valued terms.`
	var total int64 = 0
	for i := eu.NewFibonacciCounter(); i.Value < 4000000; i.Next() {
		if i.Value % 2 == 0 {
			total += i.Value
		}
	}
	output(2, desc, total)
}

//////////////////// problem 3 ////////////////////
func problem3() {
	desc := `
The prime factors of 13195 are 5, 7, 13 and 29.

What is the largest prime factor of the number 600851475143 ?

NOTES
-------------
Not very many optimizations - basically uses Eratosthenes Sieve to
generate prime numbers and then does trial division with them up to
sqrt(n).  `
	prime_factors := eu.PrimeFactors(600851475143)
	output(3, desc, prime_factors)
}

//////////////////// problem 4 ////////////////////
func problem4() {
	desc := `
A palindromic number reads the same both ways. The largest palindrome
made from the product of two 2-digit numbers is 9009 = 91 Ã— 99.

Find the largest palindrome made from the product of two 3-digit
numbers.

NOTES
-------------
  * looking for largest palindrome means that the search should start
    from the largest 3 digit number and proceed down
  * Take a palindromic 6 digit number with digits a, b, c:
        P = 100000a + 10000b + 1000c + 100c + 10b + a
          = 100001a + 10010b + 1100c
          = 11(9091a + 910b + 100c)
    This means that P must have 11 as a factor, which means that one
    of the 2 three digit numbers must have 11 as a factor (since 11 is
    prime)`
	var largestPalindrome int64 = 0
	for a := int64(999); a >= 100; a-- {
		var bstart int64 = 990 // largest 3 digit number divisible by 11
		var bstep  int64 =  11
		if a % 11 == 0 {
			bstart = 999
			bstep  = 1
		}
		for b := bstart; b >= 100; b -= bstep {
			prod := a * b
			if prod <= largestPalindrome {
				break
			}
			if prod == eu.Reverse(prod) {
				largestPalindrome = prod
			}
		}
	}
	output(4, desc, largestPalindrome)
}

//////////////////// problem 5 ////////////////////
func problem5() {
	desc := `
2520 is the smallest number that can be divided by each of the numbers
from 1 to 10 without any remainder.

What is the smallest positive number that is evenly divisible by all
of the numbers from 1 to 20?

NOTES
--------------------
Let n be the smallest number divisible by integers 2..k.

At a minimum, N has to contain all the prime numbers <= k
as factors.  The non-prime integers have to be factorized
and any factors not yet represented by just the prime numbers
need to be included.  For the case of 20:

2 * 3 * 2 * 5 * 7 * 2 * 3 * 11 * 13 * 2 * 17 * 19 = 232792560
`
	var k int64 = 20
	ps := eu.NewPrimeSieve()
	factors := make(map[int64]int64)
	for i := int64(2); i <= k; i++ {
		if i == ps.Value {
			factors[i] = 1
			ps.Next()
		} else {
			ifact := eu.IntFreq(eu.PrimeFactors(i))
			for ii, ni := range(ifact) {
				if nc, ok := factors[ii]; ok {
					if ni > nc {
						factors[ii] = ni
					}
				} else {
					factors[ii] = ni
				}
			}
		}
	}
	var product int64 = 1
	for i, n := range factors {
		product *= eu.Pow(i, n)
	}
	output(5, desc, product)
}
			
			