package main


import (
	"fmt"
	"os"
	"strconv"
	"strings"
	eu "github.com/wresch/euler_go"
)

var problems = map[string]func(){
	"1": problem1,
	"2": problem2,
	"3": problem3,
	"4": problem4,
	"5": problem5,
	"6": problem6,
	"7": problem7,
	"8": problem8,
	"9": problem9,
	"10": problem10,
	"11": problem11,
}

func main() {
	if len(os.Args) == 1 {
		fmt.Println("Usage: euler_go problem_nr")
		os.Exit(1)
	}
	if fun, ok := problems[os.Args[1]]; ok {
		fun()
	} else {
		fmt.Println("That problem was not solved yet; Solved problems:")
		for problem := range problems {
			fmt.Printf("%4s\n", problem)
		}
		os.Exit(1)
	}
}

func output(i int, desc string, solution interface{}) {
	fmt.Println("%****************************************************************")
	fmt.Printf(`\section{Problem %4d}`, i)
	fmt.Println("\n%****************************************************************")
	fmt.Println(`\subsection{Description and approach}`)
	fmt.Printf("%s\n", desc)
	fmt.Println(`\subsection{Solution}`)
	fmt.Printf("%v\n", solution)
}


//////////////////// problem1 ////////////////////
func problem1() {
	desc := `
If we list all the natural numbers below 10 that are multiples
of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.

\emph{Find the sum of all the multiples of 3 or 5 below 1000}.

My solution to this is just brute force.
`
	var total int64 = 0
	for i := eu.NewLinearCounter(3, 3); i.Value < 1000; i.Next() {
		total += i.Value
	}
	for i := eu.NewLinearCounter(5, 5); i.Value < 1000; i.Next() {
		if i.Value % 3 == 0 {
			continue
		}
		total += i.Value
	}
	output(1, desc, total)
}

//////////////////// problem2 ////////////////////
func problem2() {
	desc := `
Each new term in the Fibonacci sequence is generated by adding the
previous two terms. By starting with 1 and 2, the first 10 terms will
be:

	1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

\emph{By considering the terms in the Fibonacci sequence whose values do not
exceed four million, find the sum of the even-valued terms.}

This problem was solved by implementing a generator that supplies an
infinite list of numbers from the Fibonacci series and then summing
the even numbers.  This is essentially a brute force approach.
`
	var total int64 = 0
	for i := eu.NewFibonacciCounter(); i.Value < 4000000; i.Next() {
		if i.Value % 2 == 0 {
			total += i.Value
		}
	}
	output(2, desc, total)
}

//////////////////// problem 3 ////////////////////
func problem3() {
	desc := `
The prime factors of 13195 are 5, 7, 13 and 29.

\emph{What is the largest prime factor of the number 600851475143 ?}

Not very many optimizations - my algorithm basically uses Eratosthenes Sieve to
generate prime numbers and then does trial division with them up to
\(\sqrt(k)\).  `
	prime_factors := eu.PrimeFactors(600851475143)
	output(3, desc, prime_factors)
}

//////////////////// problem 4 ////////////////////
func problem4() {
	desc := `
A palindromic number reads the same both ways. The largest palindrome
made from the product of two 2-digit numbers is 9009 = 91 × 99.

\emph{Find the largest palindrome made from the product of two 3-digit
numbers.}

The first things to do is to only consider unique products and
start from the largest three digit number (since the largest
6 digit palindrome is sought).

Next, let us consider a palindromic 6 digit number with digits a, b, c:
\begin{equation}\begin{align}
        P &=& 100000a + 10000b + 1000c + 100c + 10b + a \\
          &=& 100001a + 10010b + 1100c \\
          &=& 11(9091a + 910b + 100c)
\end{align}\end{equation}
This means that P must have 11 as a factor, which means that one
of the 2 three digit numbers must have 11 as a factor (since 11 is
prime). This can be used to limit the search space.`
	var largestPalindrome int64 = 0
	for a := int64(999); a >= 100; a-- {
		var bstart int64 = 990 // largest 3 digit number divisible by 11
		var bstep  int64 =  11
		if a % 11 == 0 {
			bstart = 999
			bstep  = 1
		}
		for b := bstart; b >= 100; b -= bstep {
			prod := a * b
			if prod <= largestPalindrome {
				break
			}
			if prod == eu.Reverse(prod) {
				largestPalindrome = prod
			}
		}
	}
	output(4, desc, largestPalindrome)
}

//////////////////// problem 5 ////////////////////
func problem5() {
	desc := `
2520 is the smallest number that can be divided by each of the numbers
from 1 to 10 without any remainder.

\emph{What is the smallest positive number that is evenly divisible by all
of the numbers from 1 to 20?}

Let \(n\) be the smallest number divisible by integers \(2..k\).

At a minimum, n has to contain all the prime numbers \(<= k\)
as factors.  The non-prime integers have to be factorized
and any factors not yet represented by just the prime numbers
need to be included.  For the case of 20:
\begin{equation}
2 * 3 * 2 * 5 * 7 * 2 * 3 * 11 * 13 * 2 * 17 * 19 = 232792560
\end{equation}`
	var k int64 = 20
	ps := eu.NewPrimeSieve()
	factors := make(map[int64]int64)
	for i := int64(2); i <= k; i++ {
		if i == ps.Value {
			factors[i] = 1
			ps.Next()
		} else {
			ifact := eu.IntFreq(eu.PrimeFactors(i))
			for ii, ni := range(ifact) {
				if nc, ok := factors[ii]; ok {
					if ni > nc {
						factors[ii] = ni
					}
				} else {
					factors[ii] = ni
				}
			}
		}
	}
	var product int64 = 1
	for i, n := range factors {
		product *= eu.Pow(i, n)
	}
	output(5, desc, product)
}
			
//////////////////// problem 6 ////////////////////
func problem6() {
	desc := `
The sum of the squares of the first ten natural numbers is,
\begin{equation}
	1^2 + 2^2 + ... + 10^2 = 385
\end{equation}
The square of the sum of the first ten natural numbers is,
\begin{equation}
	(1 + 2 + ... + 10)^22 = 55^2 = 3025
\end{equation}
Hence the difference between the sum of the squares of the first ten
natural numbers and the square of the sum is 3025 − 385 = 2640.

\emph{Find the difference between the sum of the squares of the first one
hundred natural numbers and the square of the sum.}

To simplify the sum of integers from 1 to $k$ if $k$ is even, we can rearrange 
\begin{equation}\begin{align}
\sum_{i=1}^k i &=& 1 + 2 + ... + (k - 1) + k \\
 &=& (1 + k) + (2 + (k - 1)) + ... \\
 &=& (1 + k) \frac{1}{2} k \\
 &=& \frac{(1 + k)k}{2}
\end{align}\end{equation}

Odd numbers can be partitioned in the sum up to the preceeding odd
number plus the number
\begin{equation}\begin{align}
\sum_{i=1}^k i &=& \sum_{i=1}^{k-1}i + k \\
 &=& \frac{(1 + k - 1) * (k - 1)}{2} + frac{2k}{2} \\
 &=& \frac{(1 + k)k}{2}
\end{align}\end{equation}

A more general proof for this solution is based on the
simple equality
\begin{equation}\begin{align}
(n + 1)^2 &=& n^2 + 2n + 1
(n + 1)^2 - n^2 &=& 2n + 1
\end{align}\end{equation}

We can write this out for all numbers from 1 to $k$
\begin{equation}\begin{align}
(1 + 1)^2 - 1^2 &=& 2*1 + 1 \\
(2 + 1)^2 - 2^2 &=& 2*2 + 1 \\
(3 + 1)^2 - 3^2 &=& 2*3 + 1 \\
... \\
(k + 1)^2 - k^2 &=& 2*k + 1
\end{align}\end{equation}

If we add up the terms on the left side, 
most terms cancel out except for $(k + 1)^2$ and
$-1$, which gives
\begin{equation}\begin{align}
(k + 1)^2 - 1 &=& 2\sum_{i=1}^k i + k \\
\sum_{i=1}^k i &=& \frac{(k + 1)^2 - 1 - k}{2} \\
\sum_{i=1}^k i &=& \frac{k(k + 1)}{2}
\end{align}\end{equation}

the same result as above.  The advantage of this
proof is that it can also be applied to other series. For example
\begin{equation}\begin{align}
(n + 1)^3 &=& n^3 + 3n^2 + 3n + 1 \\
(n + 1)^3 - n^3 &=& 3n^2 + 3n + 1 \\

(1 + 1)^3 - 1^3 &=& 3 * 1^2 + 3*1 + 1 \\
(2 + 1)^3 - 2^3 &=& 3 * 2^2 + 3*2 + 1 \\
... \\
(k + 1)^3 + k^3 &=& 3 * k^2 + 3*k + 1
\end{align}\end{equation}
Summing up left side and right side as before
\begin{equation}\begin{align}
(k + 1)^3 - 1 &=& 3\sum_{i=1}^k i^2 + 2\sum_{i=1}^k i + k
\sum_{i=1}^k i^2 &=& \frac{k(k + 1)(2k + 1)}{6}
\end{align}\end{equation}
`
	output(6, desc, eu.Pow(eu.SumOfNaturalsUpTo(100), 2) -
		eu.SumOfNaturalSquaresUpTo(100))
}

//////////////////// problem 7 ////////////////////
func problem7() {
	desc := `
By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can
see that the 6th prime is 13.

\emph{What is the 10 001st prime number?}

This just reuses the prime number generator from a previous problem
`
	ps := eu.NewPrimeSieve()
	for i := 1; i < 10001; i++ {
		ps.Next()
	}
	output(7, desc, ps.Value)
}

//////////////////// problem 8 ////////////////////
func problem8() {
	desc := `
\emph{Find the greatest product of five consecutive digits
in the 1000-digit number ... (not shown here)}`
	ns := "73167176531330624919225119674426574742355349194934" +
"96983520312774506326239578318016984801869478851843" +
"85861560789112949495459501737958331952853208805511" +
"12540698747158523863050715693290963295227443043557" +
"66896648950445244523161731856403098711121722383113" +
"62229893423380308135336276614282806444486645238749" +
"30358907296290491560440772390713810515859307960866" +
"70172427121883998797908792274921901699720888093776" +
"65727333001053367881220235421809751254540594752243" +
"52584907711670556013604839586446706324415722155397" +
"53697817977846174064955149290862569321978468622482" +
"83972241375657056057490261407972968652414535100474" +
"82166370484403199890008895243450658541227588666881" +
"16427171479924442928230863465674813919123162824586" +
"17866458359124566529476545682848912883142607690042" +
"24219022671055626321111109370544217506941658960408" +
"07198403850962455444362981230987879927244284909188" +
"84580156166097919133875499200524063689912560717606" +
"05886116467109405077541002256983155200055935729725" +
"71636269561882670428252483600823257530420752963450"
	n := make([]int64, len(ns))
	for i, r := range ns {
		n[i] = int64(r) - 48
	}
	var max int64 = 0
	for i := int64(0); i <= int64(len(ns)) - 5; i++ {
		p := eu.SliceProd(n[i:(i+5)])
		if p > max {
			max = p
		}
	}
	output(8, desc, max)
}

//////////////////// problem 9 ////////////////////
func problem9() {
	desc := `
A Pythagorean triplet is a set of three natural numbers, $a < b < c$,
for which
\[a^2 + b^2 = c^2\]

For example,
\[3^2 + 4^2 = 9 + 16 = 25 = 5^2\].

\emph{There exists exactly one Pythagorean triplet for which $a + b + c
= 1000$.  Find the product abc.}

The solution to this problem makes use of Euclid's formula
\[
    a = m^2 - n^2 ,\ \, b = 2mn ,\ \, c = m^2 + n^2
\]
.  I tried to derive this formula myself, but did not succeed. This
needs more work
`
	for n := int64(1); n < 100; n++ {
		for m := n + 1; m < 101; m++ {
			a := m * m - n * n
			b := 2 * m * n
			c := m * m + n * n
			if a + b + c == 1000 {
				output(9, desc, fmt.Sprintf("(%d, %d, %d); Product = ", a, b, c, a * b * c))
				return
			}
		}
	}
	output(9, desc, "FAILED TO FIND SOLUTION")
}

//////////////////// problem 10 ///////////////////
func problem10() {
	desc := `
The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17.

\emph{Find the sum of all the primes below two million.}

Solution reused the prime sive from a previous problem.
Eventually, i probably need a better implementation of
the sieve.  The current implementation has the advantage
of creating an endless series, but it does not store
previous results and is relatively inefficient. This
code took 2m on helix.`
	ps := eu.NewPrimeSieve()
	var total int64 = 0
	for ; ps.Value < 2000000; ps.Next() {
		total += ps.Value
	}
	output(10, desc, total)
}

//////////////////// problem 11 ///////////////////
func problem11() {
	desc := `
In the 20×20 grid below, four numbers along a diagonal line have been
marked in red.

\begin{verbatim}
%s
\end{verbatim}

The product of these numbers is \(26 * 63 * 78 * 14 = 1788696\).

\emph{What is the greatest product of four adjacent numbers in the
same direction (up, down, left, right, or diagonally) in the 20×20
grid?}

There are basically two things to solve here - how to read
in the data and how to create indices for i adjacent
numbers in an m x n grid.`

	mats := `08 02 22 97 38 15 00 40 00 75 04 05 07 78 52 12 50 77 91 08
49 49 99 40 17 81 18 57 60 87 17 40 98 43 69 48 04 56 62 00
81 49 31 73 55 79 14 29 93 71 40 67 53 88 30 03 49 13 36 65
52 70 95 23 04 60 11 42 69 24 68 56 01 32 56 71 37 02 36 91
22 31 16 71 51 67 63 89 41 92 36 54 22 40 40 28 66 33 13 80
24 47 32 60 99 03 45 02 44 75 33 53 78 36 84 20 35 17 12 50
32 98 81 28 64 23 67 10 26 38 40 67 59 54 70 66 18 38 64 70
67 26 20 68 02 62 12 20 95 63 94 39 63 08 40 91 66 49 94 21
24 55 58 05 66 73 99 26 97 17 78 78 96 83 14 88 34 89 63 72
21 36 23 09 75 00 76 44 20 45 35 14 00 61 33 97 34 31 33 95
78 17 53 28 22 75 31 67 15 94 03 80 04 62 16 14 09 53 56 92
16 39 05 42 96 35 31 47 55 58 88 24 00 17 54 24 36 29 85 57
86 56 00 48 35 71 89 07 05 44 44 37 44 60 21 58 51 54 17 58
19 80 81 68 05 94 47 69 28 73 92 13 86 52 17 77 04 89 55 40
04 52 08 83 97 35 99 16 07 97 57 32 16 26 26 79 33 27 98 66
88 36 68 87 57 62 20 72 03 46 33 67 46 55 12 32 63 93 53 69
04 42 16 73 38 25 39 11 24 94 72 18 08 46 29 32 40 62 76 36
20 69 36 41 72 30 23 88 34 62 99 69 82 67 59 85 74 04 36 16
20 73 35 29 78 31 90 01 74 31 49 71 48 86 81 16 23 57 05 54
01 70 54 71 83 51 54 69 16 92 33 48 61 43 52 01 89 19 67 48`
	nrow, ncol, ntuple := 20, 20, 4
	mat := make([][]int, nrow)
	for i := range mat {
		mat[i] = make([]int, ncol)
	}
	for i, r := range strings.Split(mats, "\n") {
		for j, c := range strings.Split(r, " ") {
			n, err := strconv.Atoi(c)
			if err == nil {
				mat[i][j] = n
			} else {
				fmt.Fprintln(os.Stderr, "Could not convert ", c, " to number")
				os.Exit(1)
			}
		}
	}
	// get all adjacent n-tuples
	max := 0
	cur := 1
	for i := 0; i <= nrow - 1; i++ {
		for j := 0; j <= ncol - 1; j++ {
			if mat[i][j] == 0 {
				continue
			}
			// to the right
			if j <= ncol - ntuple {
				for dj := 0; dj < ntuple; dj++ {
					cur *= mat[i][j + dj]
				}
				if cur > max {
					max = cur
				}
				cur = 1
			}
			// down
			if i <= nrow - ntuple {
				for di := 0; di < ntuple; di++ {
					cur *= mat[i + di][j]
				}
				if cur > max {
					max = cur
				}
				cur = 1
			}
			// diagonal
			if j <= ncol - ntuple && i <= nrow - ntuple {
				for di, dj := 0, 0; di < ntuple; di, dj = di + 1, dj + 1 {
					cur *= mat[i + di][j + dj]
				}
				if cur > max {
					max = cur
				}
				cur = 1
			}
			if j >= ntuple - 1 && i <= nrow - ntuple {
				for di, dj := 0, 0; di < ntuple; di, dj = di + 1, dj - 1 {
					cur *= mat[i + di][j + dj]
				}
				if cur > max {
					max = cur
				}
				cur = 1
			}
		}
	}
		
	output(11, fmt.Sprintf(desc, mats), max)
}

//////////////////// problem 12 ///////////////////
func problem12() {
	desc := `
The sequence of triangle numbers is generated by adding the natural
numbers. So the 7th triangle number would be \(1 + 2 + 3 + 4 + 5 + 6 + 7
= 28\). The first ten terms would be:

	\[1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...\]

Let us list the factors of the first seven triangle numbers:

\begin{verbatim}
	     1: 1
	     3: 1,3
	     6: 1,2,3,6
	    10: 1,2,5,10
	    15: 1,3,5,15
	    21: 1,3,7,21
	    28: 1,2,4,7,14,28
\end{verbatim}

We can see that 28 is the first triangle number to have over five
divisors.

\emph{What is the value of the first triangle number to have over five
hundred divisors?}

To solve this problem, we take advantage of the solution for the
sum of natural numbers:
	\[ \sum_{i=1}^k i = \frac{k(k + 1)}{2} \]
So we can easily generate the triangle numbers.  Furthermore, the smallest
number with 500 distinct divisors

And the already written prime factorization algorithm.`
	output(12, desc, "")
}