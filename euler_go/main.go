package main


import (
	"fmt"
	"os"
	//"strconv"
	eu "github.com/wresch/euler_go"
)

var problems = map[string]func(){
	"1": problem1,
	"2": problem2,
	"3": problem3,
	"4": problem4,
	"5": problem5,
	"6": problem6,
	"7": problem7,
	"8": problem8,
}

func main() {
	if len(os.Args) == 1 {
		fmt.Println("Usage: euler_go problem_nr")
		os.Exit(1)
	}
	if fun, ok := problems[os.Args[1]]; ok {
		fun()
	} else {
		fmt.Println("That problem was not solved yet; Solved problems:")
		for problem := range problems {
			fmt.Printf("%4s\n", problem)
		}
		os.Exit(1)
	}
}

func output(i int, desc string, solution interface{}) {
	fmt.Println("%****************************************************************")
	fmt.Printf(`\section{Problem %4d}`, i)
	fmt.Println("\n%****************************************************************")
	fmt.Println(`\subsection{Description and approach}`)
	fmt.Printf("%s\n", desc)
	fmt.Println(`\subsection{Solution}`)
	fmt.Printf("%v\n", solution)
}


//////////////////// problem1 ////////////////////
func problem1() {
	desc := `
If we list all the natural numbers below 10 that are multiples
of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.

\emph{Find the sum of all the multiples of 3 or 5 below 1000}.

My solution to this is just brute force.
`
	var total int64 = 0
	for i := eu.NewLinearCounter(3, 3); i.Value < 1000; i.Next() {
		total += i.Value
	}
	for i := eu.NewLinearCounter(5, 5); i.Value < 1000; i.Next() {
		if i.Value % 3 == 0 {
			continue
		}
		total += i.Value
	}
	output(1, desc, total)
}

//////////////////// problem2 ////////////////////
func problem2() {
	desc := `
Each new term in the Fibonacci sequence is generated by adding the
previous two terms. By starting with 1 and 2, the first 10 terms will
be:

	1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

\emph{By considering the terms in the Fibonacci sequence whose values do not
exceed four million, find the sum of the even-valued terms.}

This problem was solved by implementing a generator that supplies an
infinite list of numbers from the Fibonacci series and then summing
the even numbers.  This is essentially a brute force approach.
`
	var total int64 = 0
	for i := eu.NewFibonacciCounter(); i.Value < 4000000; i.Next() {
		if i.Value % 2 == 0 {
			total += i.Value
		}
	}
	output(2, desc, total)
}

//////////////////// problem 3 ////////////////////
func problem3() {
	desc := `
The prime factors of 13195 are 5, 7, 13 and 29.

\emph{What is the largest prime factor of the number 600851475143 ?}

Not very many optimizations - my algorithm basically uses Eratosthenes Sieve to
generate prime numbers and then does trial division with them up to
\(\sqrt(k)\).  `
	prime_factors := eu.PrimeFactors(600851475143)
	output(3, desc, prime_factors)
}

//////////////////// problem 4 ////////////////////
func problem4() {
	desc := `
A palindromic number reads the same both ways. The largest palindrome
made from the product of two 2-digit numbers is 9009 = 91 × 99.

\emph{Find the largest palindrome made from the product of two 3-digit
numbers.}

The first things to do is to only consider unique products and
start from the largest three digit number (since the largest
6 digit palindrome is sought).

Next, let us consider a palindromic 6 digit number with digits a, b, c:
\begin{equation}\begin{align}
        P &=& 100000a + 10000b + 1000c + 100c + 10b + a \\
          &=& 100001a + 10010b + 1100c \\
          &=& 11(9091a + 910b + 100c)
\end{align}\end{equation}
This means that P must have 11 as a factor, which means that one
of the 2 three digit numbers must have 11 as a factor (since 11 is
prime). This can be used to limit the search space.`
	var largestPalindrome int64 = 0
	for a := int64(999); a >= 100; a-- {
		var bstart int64 = 990 // largest 3 digit number divisible by 11
		var bstep  int64 =  11
		if a % 11 == 0 {
			bstart = 999
			bstep  = 1
		}
		for b := bstart; b >= 100; b -= bstep {
			prod := a * b
			if prod <= largestPalindrome {
				break
			}
			if prod == eu.Reverse(prod) {
				largestPalindrome = prod
			}
		}
	}
	output(4, desc, largestPalindrome)
}

//////////////////// problem 5 ////////////////////
func problem5() {
	desc := `
2520 is the smallest number that can be divided by each of the numbers
from 1 to 10 without any remainder.

\emph{What is the smallest positive number that is evenly divisible by all
of the numbers from 1 to 20?}

Let \(n\) be the smallest number divisible by integers \(2..k\).

At a minimum, n has to contain all the prime numbers \(<= k\)
as factors.  The non-prime integers have to be factorized
and any factors not yet represented by just the prime numbers
need to be included.  For the case of 20:
\begin{equation}
2 * 3 * 2 * 5 * 7 * 2 * 3 * 11 * 13 * 2 * 17 * 19 = 232792560
\end{equation}`
	var k int64 = 20
	ps := eu.NewPrimeSieve()
	factors := make(map[int64]int64)
	for i := int64(2); i <= k; i++ {
		if i == ps.Value {
			factors[i] = 1
			ps.Next()
		} else {
			ifact := eu.IntFreq(eu.PrimeFactors(i))
			for ii, ni := range(ifact) {
				if nc, ok := factors[ii]; ok {
					if ni > nc {
						factors[ii] = ni
					}
				} else {
					factors[ii] = ni
				}
			}
		}
	}
	var product int64 = 1
	for i, n := range factors {
		product *= eu.Pow(i, n)
	}
	output(5, desc, product)
}
			
//////////////////// problem 6 ////////////////////
func problem6() {
	desc := `
The sum of the squares of the first ten natural numbers is,
\begin{equation}
	1^2 + 2^2 + ... + 10^2 = 385
\end{equation}
The square of the sum of the first ten natural numbers is,
\begin{equation}
	(1 + 2 + ... + 10)^22 = 55^2 = 3025
\end{equation}
Hence the difference between the sum of the squares of the first ten
natural numbers and the square of the sum is 3025 − 385 = 2640.

\emph{Find the difference between the sum of the squares of the first one
hundred natural numbers and the square of the sum.}

To simplify the sum of integers from 1 to $k$ if $k$ is even, we can rearrange 
\begin{equation}\begin{align}
\sum_{i=1}^k i &=& 1 + 2 + ... + (k - 1) + k \\
 &=& (1 + k) + (2 + (k - 1)) + ... \\
 &=& (1 + k) \frac{1}{2} k \\
 &=& \frac{(1 + k)k}{2}
\end{align}\end{equation}

Odd numbers can be partitioned in the sum up to the preceeding odd
number plus the number
\begin{equation}\begin{align}
\sum_{i=1}^k i &=& \sum_{i=1}^{k-1}i + k \\
 &=& \frac{(1 + k - 1) * (k - 1)}{2} + frac{2k}{2} \\
 &=& \frac{(1 + k)k}{2}
\end{align}\end{equation}

A more general proof for this solution is based on the
simple equality
\begin{equation}\begin{align}
(n + 1)^2 &=& n^2 + 2n + 1
(n + 1)^2 - n^2 &=& 2n + 1
\end{align}\end{equation}

We can write this out for all numbers from 1 to $k$
\begin{equation}\begin{align}
(1 + 1)^2 - 1^2 &=& 2*1 + 1 \\
(2 + 1)^2 - 2^2 &=& 2*2 + 1 \\
(3 + 1)^2 - 3^2 &=& 2*3 + 1 \\
... \\
(k + 1)^2 - k^2 &=& 2*k + 1
\end{align}\end{equation}

If we add up the terms on the left side, 
most terms cancel out except for $(k + 1)^2$ and
$-1$, which gives
\begin{equation}\begin{align}
(k + 1)^2 - 1 &=& 2\sum_{i=1}^k i + k \\
\sum_{i=1}^k i &=& \frac{(k + 1)^2 - 1 - k}{2} \\
\sum_{i=1}^k i &=& \frac{k(k + 1)}{2}
\end{align}\end{equation}

the same result as above.  The advantage of this
proof is that it can also be applied to other series. For example
\begin{equation}\begin{align}
(n + 1)^3 &=& n^3 + 3n^2 + 3n + 1 \\
(n + 1)^3 - n^3 &=& 3n^2 + 3n + 1 \\

(1 + 1)^3 - 1^3 &=& 3 * 1^2 + 3*1 + 1 \\
(2 + 1)^3 - 2^3 &=& 3 * 2^2 + 3*2 + 1 \\
... \\
(k + 1)^3 + k^3 &=& 3 * k^2 + 3*k + 1
\end{align}\end{equation}
Summing up left side and right side as before
\begin{equation}\begin{align}
(k + 1)^3 - 1 &=& 3\sum_{i=1}^k i^2 + 2\sum_{i=1}^k i + k
\sum_{i=1}^k i^2 &=& \frac{k(k + 1)(2k + 1)}{6}
\end{align}\end{equation}
`
	output(6, desc, eu.Pow(eu.SumOfNaturalsUpTo(100), 2) -
		eu.SumOfNaturalSquaresUpTo(100))
}

//////////////////// problem 7 ////////////////////
func problem7() {
	desc := `
By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can
see that the 6th prime is 13.

\emph{What is the 10 001st prime number?}

This just reuses the prime number generator from a previous problem
`
	ps := eu.NewPrimeSieve()
	for i := 1; i < 10001; i++ {
		ps.Next()
	}
	output(7, desc, ps.Value)
}

//////////////////// problem 8 ////////////////////
func problem8() {
	desc := `
\emph{Find the greatest product of five consecutive digits
in the 1000-digit number ... (not shown here)}`
	ns := "73167176531330624919225119674426574742355349194934" +
"96983520312774506326239578318016984801869478851843" +
"85861560789112949495459501737958331952853208805511" +
"12540698747158523863050715693290963295227443043557" +
"66896648950445244523161731856403098711121722383113" +
"62229893423380308135336276614282806444486645238749" +
"30358907296290491560440772390713810515859307960866" +
"70172427121883998797908792274921901699720888093776" +
"65727333001053367881220235421809751254540594752243" +
"52584907711670556013604839586446706324415722155397" +
"53697817977846174064955149290862569321978468622482" +
"83972241375657056057490261407972968652414535100474" +
"82166370484403199890008895243450658541227588666881" +
"16427171479924442928230863465674813919123162824586" +
"17866458359124566529476545682848912883142607690042" +
"24219022671055626321111109370544217506941658960408" +
"07198403850962455444362981230987879927244284909188" +
"84580156166097919133875499200524063689912560717606" +
"05886116467109405077541002256983155200055935729725" +
"71636269561882670428252483600823257530420752963450"
	n := make([]int64, len(ns))
	for i, r := range ns {
		n[i] = int64(r) - 48
	}
	var max int64 = 0
	for i := 0; i <= len(ns) - 5; i++ {
		p := eu.SliceProd(n[i:(i+5)])
		if p > max {
			max = p
		}
	}
	output(8, desc, max)
}